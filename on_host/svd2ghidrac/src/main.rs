use std::fs::File;
use std::io::Read;
use std::path::PathBuf;

use clap::Parser;
use sxd_document::parser::parse;
use sxd_xpath::nodeset::{Node, Nodeset};
use sxd_xpath::{Context, Factory, Value as XPathValue, XPath};

#[derive(Parser)]
struct Args {
    #[clap(help = "SVD file")]
    pub svd_file: PathBuf,

    #[clap(long, help = "Tag struct members as volatile")]
    pub volatile: bool,

    #[clap(long, help = "Output Ghidra stdint typedefs")]
    pub ghidra_stdint: bool,

    #[clap(long, help = "Also name structs, not only typedefs")]
    pub name_structs: bool,
}


trait XPathValueExt<'d> {
    fn nodeset(&'d self) -> Option<&'d Nodeset<'d>>;
    fn into_nodeset(self) -> Option<Nodeset<'d>>;
}
impl<'d> XPathValueExt<'d> for XPathValue<'d> {
    fn nodeset(&'d self) -> Option<&'d Nodeset<'d>> {
        match self {
            Self::Nodeset(ns) => Some(ns),
            _ => None,
        }
    }

    fn into_nodeset(self) -> Option<Nodeset<'d>> {
        match self {
            Self::Nodeset(ns) => Some(ns),
            _ => None,
        }
    }
}


fn make_xpath(xpath_factory: &Factory, path: &str) -> XPath {
    xpath_factory.build(path)
        .expect("failed to build XPath")
        .expect("parsed XPath is None")
}

fn eval_xpath_nodeset<'d, N: Into<Node<'d>>>(context: &Context<'d>, xpath: &XPath, node: N) -> Nodeset<'d> {
    xpath.evaluate(context, node)
        .expect("failed to evaluate XPath")
        .into_nodeset()
        .expect("XPath does not evaluate to nodeset")
}

fn eval_xpath_string<'d, N: Into<Node<'d>>>(context: &Context<'d>, xpath: &XPath, node: N) -> String {
    xpath.evaluate(context, node)
        .expect("failed to evaluate XPath")
        .into_string()
}

fn u32_from_str(s: &str) -> Option<u32> {
    if s.starts_with("0x") {
        u32::from_str_radix(&s[2..], 16).ok()
    } else if s.starts_with("0b") {
        u32::from_str_radix(&s[2..], 2).ok()
    } else if s.starts_with("0o") {
        u32::from_str_radix(&s[2..], 8).ok()
    } else {
        u32::from_str_radix(s, 10).ok()
    }
}


enum Register {
    Singular(String),
    Array(String, u32),
    Reserved(u32),
}


#[inline]
fn print_start(args: &Args) {
    print!("  ");
    if args.volatile {
        print!("volatile ");
    }
}


fn main() {
    let args = Args::parse();

    // load the SVD file
    let mut svd_file = File::open(&args.svd_file)
        .expect("failed to open SVD file");
    let mut svd_string = String::new();
    svd_file.read_to_string(&mut svd_string)
        .expect("failed to read SVD file");
    let doc_package = parse(&svd_string)
        .expect("failed to parse SVD file");

    let xpath_factory = Factory::new();

    let peripheral_xpath = make_xpath(&xpath_factory, "/device/peripherals/peripheral");
    let register_xpath = make_xpath(&xpath_factory, "./registers/register");
    let field_xpath = make_xpath(&xpath_factory, "./fields/field");

    let name_string_xpath = make_xpath(&xpath_factory, "./name/text()");
    let base_addr_string_xpath = make_xpath(&xpath_factory, "./baseAddress/text()");
    let address_offset_string_xpath = make_xpath(&xpath_factory, "./addressOffset/text()");
    let size_string_xpath = make_xpath(&xpath_factory, "./size/text()");
    let description_string_xpath = make_xpath(&xpath_factory, "./description/text()");
    let bit_offset_string_xpath = make_xpath(&xpath_factory, "./bitOffset/text()");
    let bit_width_string_xpath = make_xpath(&xpath_factory, "./bitWidth/text()");
    let dim_string_xpath = make_xpath(&xpath_factory, "./dim/text()");
    let dim_increment_string_xpath = make_xpath(&xpath_factory, "./dimIncrement/text()");
    let dim_index_string_xpath = make_xpath(&xpath_factory, "./dimIndex/text()");
    let alt_group_string_xpath = make_xpath(&xpath_factory, "./alternateGroup/text()");

    let xpath_context = Context::new();

    println!("/* generated by svd2gdt */");
    if args.ghidra_stdint {
        println!();
        println!("typedef sbyte int8_t;");
        println!("typedef sword int16_t;");
        println!("typedef sdword int32_t;");
        println!("typedef byte uint8_t;");
        println!("typedef word uint16_t;");
        println!("typedef dword uint32_t;");
    }
    println!();
    println!("#pragma pack(push,1)");

    let doc = doc_package.as_document();
    let peripherals = eval_xpath_nodeset(&xpath_context, &peripheral_xpath, doc.root());
    for (i, peripheral) in peripherals.document_order().into_iter().enumerate() {
        eprintln!("{}/{} peripherals output...", i, peripherals.size());

        let peri_name = eval_xpath_string(&xpath_context, &name_string_xpath, peripheral);
        let peri_descr = eval_xpath_string(&xpath_context, &description_string_xpath, peripheral);
        let base_address_string = eval_xpath_string(&xpath_context, &base_addr_string_xpath, peripheral);
        let base_address = u32_from_str(&base_address_string)
            .expect("failed to parse base address");

        let registers = eval_xpath_nodeset(&xpath_context, &register_xpath, peripheral);
        let mut offsets_and_registers = Vec::with_capacity(registers.size());
        for register in registers.document_order() {
            let reg_offset_string = eval_xpath_string(&xpath_context, &address_offset_string_xpath, register);
            let reg_offset = u32_from_str(&reg_offset_string)
                .expect("failed to parse register offset");
            offsets_and_registers.push((reg_offset, register));
        }

        offsets_and_registers.sort_unstable_by_key(|(o, _r)| *o);

        let mut register_info = Vec::new();
        let mut register_pos = 0;
        for (reg_offset, register) in offsets_and_registers {
            let reg_name_orig = eval_xpath_string(&xpath_context, &name_string_xpath, register);
            let reg_descr = eval_xpath_string(&xpath_context, &description_string_xpath, register);
            let reg_size_string = eval_xpath_string(&xpath_context, &size_string_xpath, register);
            let reg_dim_string = eval_xpath_string(&xpath_context, &dim_string_xpath, register);
            let reg_dim_incr_string = eval_xpath_string(&xpath_context, &dim_increment_string_xpath, register);
            let reg_dim_index_string = eval_xpath_string(&xpath_context, &dim_index_string_xpath, register);
            let reg_alt_group_string = eval_xpath_string(&xpath_context, &alt_group_string_xpath, register);

            if reg_alt_group_string.len() > 0 {
                continue;
            }

            let reg_name = if let Some(s) = reg_name_orig.strip_suffix("[%s]") {
                s.to_owned()
            } else {
                reg_name_orig
            };
            let reg_size = u32_from_str(&reg_size_string)
                .expect("failed to parse register size");
            let reg_dim = if reg_dim_string.len() > 0 {
                u32_from_str(&reg_dim_string)
                    .expect("failed to parse register dimension")
            } else {
                1
            };
            let reg_dim_incr = if reg_dim_incr_string.len() > 0 {
                u32_from_str(&reg_dim_incr_string)
                    .expect("failed to parse register dimension increment")
            } else {
                reg_size / 8
            };

            if reg_size % 8 != 0 {
                panic!("register {}.{} does not end on a byte boundary", peri_name, reg_name);
            }
            if reg_offset < register_pos {
                panic!("register {}.{} out of order! (at {}, expected at least {})", peri_name, reg_name, reg_offset, register_pos);
            } else if reg_offset > register_pos {
                // add padding
                register_info.push(Register::Reserved(reg_offset - register_pos));
            }
            if reg_dim_incr != reg_size / 8 {
                panic!("unexpected register {}.{} increment: expected {}, got {}", peri_name, reg_name, reg_size / 8, reg_dim_incr);
            }
            if reg_dim_index_string.len() > 0 {
                if reg_dim_index_string != format!("0-{}", reg_dim-1) {
                    panic!("register {}.{} dimension indexes are unexpected (got {:?}, expected \"0-{}\")", peri_name, reg_name, reg_dim_index_string, reg_dim-1);
                }
            }

            register_pos = reg_offset + reg_dim * reg_size / 8;

            println!();
            println!("/** {} */", reg_descr);
            print!("typedef struct");
            if args.name_structs {
                print!(" {}_{}_s", peri_name, reg_name);
            }
            println!(" {{");

            let fields = eval_xpath_nodeset(&xpath_context, &field_xpath, register);
            let mut current_bit = 0;
            let mut field_reserved_index = 0;
            for field in fields.document_order() {
                let field_name = eval_xpath_string(&xpath_context, &name_string_xpath, field);
                let field_descr = eval_xpath_string(&xpath_context, &description_string_xpath, field);
                let field_offset_string = eval_xpath_string(&xpath_context, &bit_offset_string_xpath, field);
                let field_width_string = eval_xpath_string(&xpath_context, &bit_width_string_xpath, field);
                let field_offset = u32_from_str(&field_offset_string)
                    .expect("failed to parse field offset");
                let field_width = u32_from_str(&field_width_string)
                    .expect("failed to parse field width");

                if current_bit < field_offset {
                    print_start(&args);
                    println!("uint{}_t reserved{} : {};", reg_size, field_reserved_index, field_offset - current_bit);
                    field_reserved_index += 1;
                } else if current_bit > field_offset {
                    panic!("out of order field! we are at {}, offset is {}", current_bit, field_offset);
                }

                println!("  /** {} */", field_descr);
                print_start(&args);
                println!("uint{}_t {} : {};", reg_size, field_name, field_width);
                current_bit = field_offset + field_width;
            }

            if current_bit < reg_size {
                print_start(&args);
                println!("uint{}_t reserved_tail : {};", reg_size, reg_size - current_bit);
            }

            println!("}} {}_{};", peri_name, reg_name);

            if reg_dim == 1 {
                register_info.push(Register::Singular(reg_name.clone()));
            } else {
                register_info.push(Register::Array(reg_name.clone(), reg_dim));
            }
        }

        println!();
        println!("/** {} */", peri_descr);
        print!("typedef struct");
        if args.name_structs {
            print!(" {}_s", peri_name);
        }
        println!(" {{");
        let mut reserved_counter = 0;
        for register in register_info {
            match register {
                Register::Reserved(mut byte_count) => {
                    if byte_count >= 4 {
                        print_start(&args);
                        println!("uint32_t reserved{}[{}];", reserved_counter, byte_count / 4);
                        reserved_counter += 1;
                        byte_count %= 4;
                    }
                    if byte_count >= 2 {
                        print_start(&args);
                        println!("uint16_t reserved{}[{}];", reserved_counter, byte_count / 2);
                        reserved_counter += 1;
                        byte_count %= 2;
                    }
                    if byte_count >= 1 {
                        print_start(&args);
                        println!("uint8_t reserved{}[{}];", reserved_counter, byte_count);
                        reserved_counter += 1;
                    }
                },
                Register::Array(register_name, dimensions) => {
                    print_start(&args);
                    println!("{}_{} {}[{}];", peri_name, register_name, register_name, dimensions);
                },
                Register::Singular(register_name) => {
                    print_start(&args);
                    println!("{}_{} {};", peri_name, register_name, register_name);
                },
            }
        }
        println!("}} {};", peri_name);
    }

    println!();
    println!("#pragma pack(pop)");
}
